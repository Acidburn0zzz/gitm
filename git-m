#!/usr/bin/python3

import os
from os.path import *
import re
import json
import yaml
import ago
import sys
import signal
from sys import *
import argparse
import inspect
import traceback
from datetime import datetime
from prettytable import PrettyTable
from git.exc import InvalidGitRepositoryError, GitCommandError
from munch import Munch
import git
from git.repo.base import Repo

args = None

fields = ("dir ago count revision hash msg branch remote url linked state"
        .split())

def warn(a):
    print(a, file=sys.stderr)


def log(*_args, **kwargs):
    global args
    if args and 'verbose' in args and args.verbose:
        s1 = inspect.stack()[1]
        print("%s:%d %s < %s" % (s1.filename, s1.lineno, s1.function, inspect.stack()[2].function),
              str(*_args).rstrip(), file=sys.stderr, **kwargs)


def git_get(g):
    m = Munch()
    r = Repo(g)
    if len(r.branches):
        m.branches = [b.name for b in r.branches]
    try:
        m.hash = r.git.rev_parse('--short', 'HEAD')
        m.sha = r.commit('HEAD').hexsha
        m.msg = r.head.object.message.split('\n')[0]
        m.count = int(r.git.rev_list('--count', 'HEAD'))
        m.time_sec = r.head.commit.committed_date
        m.datetime = r.head.commit.committed_datetime
        m.revision = r.git.describe(['--always', '--contains'])
    except GitCommandError:
        m.count = 0
        # without commit
        pass
    cr = r.config_reader()
    if islink(g + '/.git/config'):
        m.linked = dirname(relpath(realpath(g + '/.git/config')))

    if cr.has_option('core', 'worktree'):
        m.worktree = cr.get_value('core', 'worktree')
    if not r.head.is_detached:
        m.branch = r.active_branch.name
    if r.remotes:
        m.remote = r.remotes[0].name
        m.url = r.remotes[0].url
    return m


def short(s):
    if s and len(s) > 16:
        return s[:15] + 'â€¦'
    return s

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--table', nargs='?', default=argparse.SUPPRESS)
    parser.add_argument('--sha', nargs='?', default=argparse.SUPPRESS,
                        help='print sha hashes in format of sha1sum utility'
                        'optionally to a file')
    parser.add_argument('--csv', nargs='?', default=argparse.SUPPRESS,
                        help='print in format csv'
                        'optionally to a file')
    parser.add_argument('--json', nargs='?', default=argparse.SUPPRESS)
    parser.add_argument('--export', nargs='?', default=argparse.SUPPRESS,
                        help='scans directory tree and saves results status.yaml')
    parser.add_argument('--compare', nargs='?', default=argparse.SUPPRESS,
                        help='scans directory tree and compares with status.yaml')
    parser.add_argument('--import', nargs='?', default=argparse.SUPPRESS,
                        help='scans directory tree and synchronizes with status.yaml')
    parser.add_argument('--verbose', action='store_true')
    parser.add_argument('--standalone_remote', action='store_true',
                        help='Skips repositories linked (not standalone) and without remotes. '
                        'Leaves only unlinked standalone with remotes. '
                        'Linked reps belong to git submodules or repo. '
                        'This reps can be replicated with parent git or repo. '
                        'Reps without remote can\'t be synced via remote.')
    parser.add_argument('d', nargs='?', default='.')
    parser.add_argument('rest', nargs='?')
    global args, argv
    args = parser.parse_args('')
    argv = argv[1:]
    while argv:
        log(argv)
        args = parser.parse_args([argv[0]], args)
        argv = argv[1:]
        log(args)
        if not isdir(args.d):
            break


class GitM(object):

    def __init__(self):
        self.loaded = self.out = self.tab = None
        self.status = {}

    def main(self):

        def print_csv(p, st):
            print("%s, %s, %d, %s, %s, %s, %s"
                  % (p, st.get('datetime', ''), st.get('count', 0), st.get('sha', ''), '"%s"' %
                     (st.get('msg', '')),
                     st.get('worktree', st.get('linked', 'standalone')),
                     st.get('remote', '') + ' ' + st.get('url', 'local')))

        def print_sha(p, st):
            print("%s  %s" % (st.sha, p)) if 'sha' in st else 0

        def table_add_row(p, st):
            r = {}
            r['dir'] = p
            r.update(dict(st))
            r['msg'] = short(r.get('msg'))
            if 'time_sec' in st:
                r['ago'] = short(ago.human(datetime.fromtimestamp(int(st.time_sec)),
                                           precision=2, past_tense='{}', future_tense='{}'))
            if 'branch' in r:
                r['branch'] = short(r['branch'])
            self.tab.add_row([r[f] if f in r else '' for f in fields])

        def git_import(d, s):
            if 'import' not in args or 'remote' not in s:
                return
            if exists(d + '/.git'):
                r = Repo(d)
            else:
                try:
                    r = Repo.clone_from(s.url, d)
                except (AttributeError, GitCommandError) as e:
                    r = Repo.init(d)
            if s.remote not in [a.name for a in r.remotes]:
                r.create_remote(s.remote, s.url)
                r.git.fetch(s.remote)
            if 'branch' in s:
                r.git.checkout(s.branch)
            if 'sha' not in s:
                return
            try:
                if s.sha != r.commit('HEAD').hexsha:
                    r.git.checkout(s.sha)
                s.state = 'imported'
            except GitCommandError:
                s.state = 'failed'
                pass
            # assure same
            if s.sha == r.commit('HEAD').hexsha:
                s.state += ' same'

        def git_compare(d, s):
            same = False
            s = Munch(s)
            if not exists(d + '/.git'):
                s.state = 'absent'
                log(d)
            else:
                r = Repo(d)
                if 'sha' in s:
                    if s.sha != r.commit('HEAD').hexsha:
                        s.state = 'different'
                    elif (not r.head.is_detached and
                          r.active_branch.name == s.get('branch', '')):
                        s.state = 'same'
                        same = True
                    else:
                        s.state = 'same detached'
            if not same:
                git_import(d, s)
            self.out(d, s)
            self.status[d] = s

        def process_args():
            if 'compare' in args:
                if not args.compare:
                    args.compare = "status.yaml"
                    if not isfile(args.compare):
                        args.compare = "status.json"
                log(args.compare)
                with open(args.compare) as f:
                    if args.compare.endswith('.yaml'):
                        self.loaded = Munch(yaml.load(f))
                    if args.compare.endswith('.json'):
                        self.loaded = Munch(json.load(f))
            else:
                if isfile('status.yaml'):
                    with open('status.yaml') as f:
                        self.loaded = Munch(yaml.load(f))

            self.out = print_sha if 'sha' in args else self.out

            if 'csv' in args:
                if not args.csv:
                    args.csv = "status.csv"
                if args.csv == '-':
                    csv = sys.stdout
                else:
                    csv = open(args.csv, "w")

            self.out = print_csv if 'csv' in args else self.out

            if not self.out:  # default output is table
                self.tab = PrettyTable(fields, border=False, header=False, align="l")
                self.tab.align = "l"
                self.out = table_add_row

        def git_for_subdir():
            log()
            #print(args.d, argv)
            cmd = ' '.join(["git -C", dirname(argv[-1]), args.d] +
                           argv[:-1] + [basename(argv[-1])])
            log(cmd)
            ret = os.system(cmd)
            return os.WEXITSTATUS(ret)

        def git_for_each():
            log()
            ret = 0
            for d, s in self.loaded.items() if self.loaded else {}:
                print("project", d)
                r = os.system(' '.join(["git -C", d, args.d] + argv))
                if os.WTERMSIG(r) == signal.SIGINT:
                    raise KeyboardInterrupt
                log(r)
                if r:
                    ret = r
            return os.WEXITSTATUS(ret)

        def scan(d):
            warn('Scanning directory tree ...')
            for path, dirs, files in os.walk(d):
                (dir, base) = split(path)
                p = re.sub(r'^\.\/', '', path)
                log(p)
                if base in ['.git', 'tmp']:
                    dirs[:] = []  # prune
                    continue
                if not ('.git' in files or '.git' in dirs):
                    continue

                try:
                    st = git_get(p)
                    # Get only remote and standalone if requested
                    if (args.standalone_remote and
                            ('remote' not in st or
                             'linked' in st or
                             'worktree' in st)):
                        continue
                    self.status[p] = dict(st)
                    if 'compare' in args and self.loaded and p not in self.loaded:
                        # only here and not in compare
                        st.state = 'undesired'
                        self.out(p, st)
                    if not self.loaded:
                        self.out(p, st)
                except (InvalidGitRepositoryError, GitCommandError, ValueError) as e:
                    warn('Error: ' + str(e) + (': ' + p if p not in str(e) else ''))
                    traceback.print_exc()


        parse_args()
        process_args()
        log(self.loaded)
        if isdir(args.d) and (not self.loaded or 'compare' in args or 'export' in args):
            # don't scan if self.loaded and not in compare mode
            scan(args.d)
        elif argv and exists(argv[-1]):
            return git_for_subdir()
        elif not isdir(args.d):
            return git_for_each()

        for d, s in self.loaded.items() if self.loaded else {}:
            try:
                git_compare(d, s)
            except (InvalidGitRepositoryError, GitCommandError,
                    ValueError) as e:
                warn('Error: ' + str(e) +
                     (': ' + d if d not in str(e) else ''))
                traceback.print_exc()

        print(self.tab) if self.tab else 0

        if 'json' in args:
            if not args.json:
                args.json = "status.json"
            if args.json == '-':
                f = sys.stdout
            else:
                f = open(args.json, "w")
            f.write(json.dumps(self.status, indent=4, default=str) + "\n")

        log(args)
        if 'export' in args:
            if not args.export:
                args.export = "status.yaml"
            if args.export == '-':
                f = sys.stdout
            else:
                f = open(args.export, "w")
            f.write(yaml.dump(self.status,
                              default_flow_style=False, default_style=''))
            warn('Exported status into file ' + args.export)


if __name__ == "__main__":
    err = GitM().main()
    if err:
        sys.exit(err)
